from IPython.core.interactiveshell import Enum
import torch

def hello():
  print('Hello from hw1_basic.py!')

##########################################################################
##########################################################################

def create_sample_tensor():

 #---------******* My Code *******----------start
  x = torch.tensor([[0, 10], [100, 0], [0, 0]])
 #---------******* My Code *******----------end

  return x

##########################################################################
##########################################################################

def mutate_tensor(x, indices, values):

 #---------******* My Code *******----------start
  for index , item in enumerate(indices):
    x[item[0], item[1]] = values[index]
 #---------******* My Code *******----------end

  return x

##########################################################################
##########################################################################

def count_tensor_elements(x):

  #---------******* My Code *******----------start
  num_elements = 1
  for item in list(list(x.shape)):
    num_elements *= item
  #---------******* My Code *******----------end

  return num_elements

##########################################################################
##########################################################################

def create_tensor_of_pi(M, N):

  #---------******* My Code *******----------start
  x = torch.full((M, N), 3.14) 
   #---------******* My Code *******----------end

  return x

##########################################################################
##########################################################################

def multiples_of_ten(start, stop):
 
  assert start <= stop

  #---------******* My Code *******----------start
  tensor = torch.arange(start, stop + 1, dtype = torch.float64)
  x = tensor[tensor % 10 == 0]
  #---------******* My Code *******----------end

  return x

##########################################################################
##########################################################################

def slice_indexing_practice(x):

  assert x.shape[0] >= 3
  assert x.shape[1] >= 5

  #---------******* My Code *******----------start
  last_row = x[-1, :]
  third_col = x[:, 2:3]
  first_two_rows_three_cols = x[:2 ,:3]
  even_rows_odd_cols = x[::2, 1::2]
  #---------******* My Code *******----------end

  out = (
    last_row,
    third_col,
    first_two_rows_three_cols,
    even_rows_odd_cols,
  )
  return out

##########################################################################
##########################################################################

def slice_assignment_practice(x):

  #---------******* My Code *******----------start
  replacement = torch.tensor([
                              [0, 1, 2, 2, 2, 2],
                              [0, 1, 2, 2, 2, 2],
                              [3, 4, 3, 4, 5, 5],
                              [3, 4, 3, 4, 5, 5],
                             ])
  x[:4, :6] = replacement
 #---------******* My Code *******----------end

  return x

##########################################################################
##########################################################################

def shuffle_cols(x):

  #---------******* My Code *******----------start
  idx1 = torch.tensor([0, 0, 2, 1])
  y = x[:x.shape[0], idx1]
  #---------******* My Code *******----------end

  return y

##########################################################################
##########################################################################

def reverse_rows(x):

  #---------******* My Code *******----------start
  idx0 = torch.arange(-1, -(x.shape[0]+1), -1)
  y = x[idx0]
  #---------******* My Code *******----------end

  return y

##########################################################################
##########################################################################

def take_one_elem_per_col(x):

  #---------******* My Code *******----------start
  idx0 = [1, 0, 3]
  idx1 = [0, 1, 2]
  y = x[idx0, idx1]
  #---------******* My Code *******----------end

  return y

##########################################################################
##########################################################################

def count_negative_entries(x):

  #---------******* My Code *******----------start
  mask = (x < 0)
  num_neg = x[mask].shape[0]
  #---------******* My Code *******----------end

  return num_neg

##########################################################################
##########################################################################

def make_one_hot(x):

  #---------******* My Code *******----------start
  y = torch.zeros((len(x), max(x)+1), dtype = torch.float32)
  for index, item in enumerate(x):
    y[index, item] = 1
  #---------******* My Code *******----------end

  return y

##########################################################################
##########################################################################


def reshape_practice(x):

  #---------******* My Code *******----------start
  y = x.view(2,3,4).permute(1, 0, 2).reshape(3,8)
  #---------******* My Code *******----------end

  return y

##########################################################################
##########################################################################

def zero_row_min(x):

  #---------******* My Code *******----------start
  y = x.clone()
  y[torch.arange(x.shape[0]), x.argmin(dim=1)] = 0
  #---------******* My Code *******----------end

  return y

##########################################################################
##########################################################################

def batched_matrix_multiply(x, y, use_loop=True):

  #---------******* My Code *******----------start
  if use_loop :
    mul_lst = []
    for B_Num in range(x.shape[0]):
      mul_lst.append(torch.matmul(x[B_Num], y[B_Num]))
    z = torch.stack(mul_lst)
  else:
    z = torch.bmm(x, y)
  #---------******* My Code *******----------end

  return z

##########################################################################
##########################################################################

def normalize_columns(x):

  #---------******* My Code *******----------start
  mean = torch.sum(x, dim = 0) / x.shape[0]
  var = torch.sum((x - mean) ** 2, dim = 0) / (x.shape[0] - 1)
  y = (x - mean) / (var ** 0.5)
  #---------******* My Code *******----------end

  return y

##########################################################################
##########################################################################


def mm_on_cpu(x, w):

  y = x.mm(w)
  return y

##########################################################################
##########################################################################

def mm_on_gpu(x, w):

  #---------******* My Code *******----------start
  x = x.cuda()
  w = w.cuda()
  y = x.mm(w)
  y = y.cpu()
  #---------******* My Code *******----------end

  return y
